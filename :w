package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/pandasoli/goterm"
)


func main() {
  argv := os.Args

  if len(argv) == 1 {
    fmt.Print(help_page)
    return
  }

  switch argv[1] {
  case "cli":
    if len(argv) > 2 {
      fmt.Print(help_page)
      return
    }

    termios, err := goterm.SetRawMode()
    if err != nil {
      panic(fmt.Errorf("Could not set terminal to raw mode: %s", err))
    }

    defer func() {
      err := goterm.RestoreMode(termios)
      if err != nil {
        panic(fmt.Errorf("Could not restore terminal mode: %s", err))
      }
    }()

    fmt.Print("\033[?1003h\033[?1015h\033[?1006h")
    fmt.Print("\033[?1002h")

    defer fmt.Print("\033[?1000l")
    defer fmt.Print("\033[?1003l\033[?1015l\033[?1006l")

    fmt.Print("\033[?47h")
    defer fmt.Print("\033[?47l")

    goterm.HideCursor()
    defer goterm.ShowCursor()

    rect := Rect { 40, 6, 4, 2 }
    selected_side := "none"

    var x, y int

    for {
      fmt.Print("\033[2J")
      makeBorder(rect, selected_side)

      debug_line = 0
      debug(fmt.Sprintf("\033[100m üå¶  \033[0m { \033[31m%d\033[0m, \033[31m%d\033[0m, \033[31m%d\033[0m, \033[31m%d \033[0m}", rect.W, rect.H, rect.X, rect.Y))
      debug(selected_side)

      goterm.GoToXY(x, y)
      fmt.Print("\033[42m \033[49m")

      key, err := goterm.Getch()
      if err != nil {
        panic(fmt.Errorf("Could not get character: %s", err))
      }

      if key == "q" || key == "\n" { break }

      if strings.HasPrefix(key, "\033[<") {
        list := strings.Split(key[3:], ";")

        ev := list[0]
        x, _ = strconv.Atoi(list[1])
        y, _ = strconv.Atoi(list[2][:len(list[2]) - 1])
        kind := list[2][len(list[2]) - 1]

        x--
        y--

        switch ev {
        case "0":
          if kind == 'M' {
            inside_x := rect.X < x && x < rect.X + rect.W
            inside_y := rect.Y < y && y < rect.Y + rect.H

            sides := map[string]bool {
              // "center": (rect.X < x && x < rect.X + rect.W) && (rect.Y < y && y < rect.Y + rect.H),

              "top": y == rect.Y && inside_x,
              "bottom": y == rect.Y + rect.H - 1 && inside_x,
              "left": x == rect.X && inside_y,
              "right": x == rect.X + rect.W - 1 && inside_y,

              "top left": x == rect.X && y == rect.Y,
              "top right": x == rect.X + rect.W + 1 && y == rect.Y,
              "bottom left": x == rect.X && y == rect.Y + rect.H + 1,
              "bottom right": x == rect.X + rect.W + 1 && y == rect.Y + rect.H + 1,
            }

            selected_side = "none"

            for side, ok := range sides {
              if ok { selected_side = side; break }
            }
          } else if kind == 'm' {
            selected_side = "none"
          }
        case "32":
          var funcs map[string]func(x, y int)
          funcs = map[string]func(x, y int) {
            "top": func(x, y int) {
              if rect.H - y < 0 { selected_side = "bottom"; funcs["bottom"](x, y); return }

              rect.Y += y
              rect.H -= y
            },
            "bottom": func(x, y int) {
              if y - 1 < 0 { selected_side = "top"; funcs["top"](x, y) }

              rect.H = y - 1
            },
          }

          if fn, ok := funcs[selected_side]; ok {
            fn(x - rect.X, y - rect.Y)
          }

          // switch selected_side {
          // case "top":
          //   y -= rect.Y

          //   rect.H -= y
          //   rect.Y += y

          //   if rect.H == 0 { selected_side = "bottom" }
          // case "bottom":
          //   rect.H = max(0, y - rect.Y - 1)
          // case "left":
          //   x -= rect.X

          //   rect.W -= x
          //   rect.X += x

          //   if rect.W == 0 { selected_side = "right" }
          // case "right":
          //   rect.W = x - rect.X - 1
          //   if rect.W == 0 { selected_side = "left" }

          // case "top left":
          //   y -= rect.Y
          //   x -= rect.X

          //   rect.H = max(0, rect.H - y)
          //   rect.Y += y
          //   rect.W = max(0, rect.W - x)
          //   rect.X += x
          // case "top right":
          //   y -= rect.Y

          //   rect.H = max(0, rect.H - y)
          //   rect.Y += y
          //   rect.W = max(0, x - rect.X - 1)
          // case "bottom left":
          //   y -= rect.Y

          //   rect.W = max(0, rect.W - x - rect.X)
          //   rect.X = x
          //   rect.H = max(0, y - rect.Y + 1)
          // case "bottom right":
          //   rect.W = max(0, x - rect.X - 1)
          //   rect.H = max(0, y - rect.Y - 1)
          // }
        }
      }
    }

  case "show":
    /*
      0: program name
      1: "show"
      2: <width>
      3: <height>
      4: <x>
      5: <y>
    */

    if len(argv) != 6 {
      fmt.Print(help_page)
      return
    }

    w, w_err := strconv.Atoi(argv[2])
    h, h_err := strconv.Atoi(argv[3])
    x, x_err := strconv.Atoi(argv[4])
    y, y_err := strconv.Atoi(argv[5])

    icon_err := "\033[30;43m üü°Ô∏è \033[39;49m"

    if w_err != nil {
      fmt.Printf(" %s D√∂n√º≈üt√ºr√ºlemedi `%s` hedef int (beklenen width).\n\n", icon_err, argv[2])
      return
    }

    if h_err != nil {
      fmt.Printf(" %s D√∂n√º≈üt√ºr√ºlemedi `%s` hedef int (beklenen heigth).\n\n", icon_err, argv[3])
      return
    }

    if x_err != nil {
      fmt.Printf(" %s D√∂n√º≈üt√ºr√ºlemedi `%s` hedef int (beklenen x).\n\n", icon_err, argv[4])
      return
    }

    if y_err != nil {
      fmt.Printf(" %s D√∂n√º≈üt√ºr√ºlemedi `%s` hedef int (beklenen y).\n\n", icon_err, argv[5])
      return
    }

    makeBorder(Rect { w, h, x, y }, "")
    fmt.Println()
  default:
    fmt.Printf(" \033[41m üçíÔ∏è \033[49m Anlayamadƒ±m `%s` se√ßenek.\n\n", argv[1])
  }
}
